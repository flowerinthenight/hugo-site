













    

    
        
    

    

    
        
    

    

    
        
    







    

    






<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"  xml:lang="en"  xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        
            

            
                
            

            
                <link href="http://localhost:1313/tags/nginx/atom.xml" rel="self" type="application/atom+xml"/>
            
        
            

            
                
            

            
                <link href="http://localhost:1313/tags/nginx/" rel="alternate" type="text/html"/>
            
        
            

            

            
                <link href="http://localhost:1313/tags/nginx/rss.xml" rel="alternate" type="application/rss+xml"/>
            
        

        

        
            <copyright>© Flowerinthenight, 2016-2024. All rights reserved.</copyright>
        

        <description>Recent content</description>

        
            <language>en</language>
        

        

        <link>http://localhost:1313/tags/nginx/</link>

        
            <managingEditor>example@example.com (John Doe)</managingEditor>
        

        <title>Nginx · Tags · About</title>

        
            <webMaster>example@example.com (John Doe)</webMaster>
        

        
            <item>
                
                
                
                
                
                
                

                

                

                

                

                
                

                

                

                
                    <description><![CDATA[<p>This post is somewhat related to a <a href="https://flowerinthenight.com/blog/2018/03/31/access-pods-k8s">previous post</a> about accessing k8s services using nginx reverse proxy. Let&rsquo;s try to add a simple basic authentication to these services at the proxy level. Now, this may come in handy in non-production environments but at the very least, make sure that you are doing this over HTTPS as basic authentication credentials are not encrypted.</p>
<p>We will be using the <code>htpasswd</code> tool to generate our passwords. In Ubuntu, you can install this using the following command:</p>
<p>{% highlight shell %}
$ sudo apt-get install apache2-utils
{% endhighlight %}</p>
<p>Let&rsquo;s generate our password file:</p>
<p>{% highlight shell %}
$ htpasswd -c passfile user1
New password:
Re-type new password:
Adding password for user user1
$ cat passfile
user1:$apr1$c/7lb2VS$SQ9pPJ8XfNpPH.jmnHRsE0
{% endhighlight %}</p>
<p>Let&rsquo;s add a config map to our previous YAML file and enable basic authentication to <code>svc1</code> only:</p>
<p>{% highlight ruby %}
apiVersion: v1
kind: ConfigMap
metadata:
name: basicauth
data:
htpasswd: |
# generate: $ htpasswd -c {file} username (then input password)
user1:$apr1$c/7lb2VS$SQ9pPJ8XfNpPH.jmnHRsE0</p>
<hr>
<p>apiVersion: v1
kind: ConfigMap
metadata:
name: serviceproxy-conf
data:
serviceproxy.conf: |
server {
listen 80;
server_name development.mobingi.com;
resolver kube-dns.kube-system.svc.cluster.local valid=10s;</p>
<pre><code>  location ~ ^/svc1/(.*)$ {
    auth_basic &quot;mobingi&quot;;
    auth_basic_user_file /etc/serviceproxy/htpasswd;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header Host $host;
    rewrite ^/svc1/(.*)$ /$1 break;
    proxy_pass &quot;http://svc1.default.svc.cluster.local&quot;;
    proxy_http_version 1.1;
  }

  location ~ ^/svc2/(.*)$ {
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header Host $host;
    rewrite ^/svc2/(.*)$ /$1 break;
    proxy_pass &quot;http://svc2.default.svc.cluster.local&quot;;
    proxy_http_version 1.1;
  }

  # root health check requirement in GKE ingress
  location / {
    return 200 'healthy\n';
  }
}
</code></pre>
<hr>
<p>apiVersion: apps/v1
kind: Deployment
metadata:
name: serviceproxy
spec:
replicas: 1
revisionHistoryLimit: 3
selector:
matchLabels:
app: serviceproxy
template:
metadata:
labels:
app: serviceproxy
spec:
containers:
- name: nginx
image: nginx:1.13
ports:
- containerPort: 80
volumeMounts:
- name: config-volume
mountPath: /etc/nginx/conf.d/
- name: htpasswd
mountPath: /etc/serviceproxy/
volumes:
- name: config-volume
configMap:
name: serviceproxy-conf
items:
- key: serviceproxy.conf
path: serviceproxy.conf
- name: htpasswd
configMap:
name: basicauth
items:
- key: htpasswd
path: htpasswd</p>
<hr>
<p>apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
name: serviceproxy-hpa
&hellip;
{% endhighlight %}</p>
<p>You should now be able to access <code>svc1</code> using your username:password.</p>
<p>{% highlight shell %}
$ curl -u user1:password <a href="https://development.mobingi.com/svc1/some-endpoint">https://development.mobingi.com/svc1/some-endpoint</a>
{% endhighlight %}</p>
<p>That&rsquo;s it!</p>
]]></description>
                

                <guid isPermaLink="false">tag:localhost:1313,0001-01-01:/blog/2019-01-31-nginx-basicauth-k8s/</guid>

                
                    <link>http://localhost:1313/blog/2019-01-31-nginx-basicauth-k8s/</link>
                

                
                    <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
                

                
                    <title>Using nginx basic authentication in Kubernetes</title>
                
            </item>
        
            <item>
                
                
                
                
                
                
                

                

                

                

                

                
                

                

                

                
                    <description><![CDATA[<p>At work, for a couple of months now, we&rsquo;ve been using <a href="https://www.getambassador.io/">Ambassador</a> as our main API gateway to our k8s services. We also have our own authorization service that uses Ambassador&rsquo;s <a href="https://www.getambassador.io/reference/services/auth-service">AuthService</a> mechanism. Recently, we&rsquo;ve had services that needed CORS support and although Ambassador has features that support the <a href="https://www.getambassador.io/reference/cors">enabling of CORS</a>, we had to update our authorization service to handle CORS-related requests. Instead of doing this, we tried adding the CORS support at the proxy level (nginx). I&rsquo;ve wrote about this topic <a href="https://flowerinthenight.com/blog/2018/03/31/access-pods-k8s">here</a> and <a href="https://flowerinthenight.com/blog/2019/01/31/nginx-basicauth-k8s">here</a>.</p>
<p>In the example below, the CORS support is added under the location <code>/svc2/</code>.</p>
<h2 id="-highlight-ruby-">{% highlight ruby %}</h2>
<p>apiVersion: v1
kind: ConfigMap
metadata:
name: serviceproxy-conf
data:
serviceproxy.conf: |
server {
listen 80;
server_name development.mobingi.com;
resolver kube-dns.kube-system.svc.cluster.local valid=10s;</p>
<pre><code>  location ~ ^/svc1/(.*)$ {
    auth_basic &quot;mobingi&quot;;
    auth_basic_user_file /etc/serviceproxy/htpasswd;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header Host $host;
    rewrite ^/svc1/(.*)$ /$1 break;
    proxy_pass &quot;http://svc1.default.svc.cluster.local&quot;;
    proxy_http_version 1.1;
  }

  location ~ ^/svc2/(.*)$ {
    # Ref: https://enable-cors.org/server_nginx.html
    if ($request_method = 'OPTIONS') {
      add_header 'Access-Control-Allow-Origin' '*';
      add_header 'Access-Control-Allow-Methods' 'POST, OPTIONS';
      # Custom headers and headers various browsers *should* be OK with but aren't.
      add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
      # Tell client that this pre-flight info is valid for 20 days.
      add_header 'Access-Control-Max-Age' 1728000;
      add_header 'Content-Type' 'text/plain; charset=utf-8';
      add_header 'Content-Length' 0;
      return 204;
    }
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_set_header Host $host;
    rewrite ^/svc2/(.*)$ /$1 break;
    proxy_pass &quot;http://svc2.default.svc.cluster.local&quot;;
    proxy_http_version 1.1;
  }

  # root health check requirement in GKE ingress
  location / {
    return 200 'healthy\n';
  }
}

{..redacted..}
</code></pre>
<p>{% endhighlight %}</p>
<p>With that said, be aware of the <a href="https://www.nginx.com/resources/wiki/start/topics/depth/ifisevil/">potential problems of using if in nginx</a>.</p>
]]></description>
                

                <guid isPermaLink="false">tag:localhost:1313,0001-01-01:/blog/2019-05-26-cors-nginx-k8s/</guid>

                
                    <link>http://localhost:1313/blog/2019-05-26-cors-nginx-k8s/</link>
                

                
                    <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
                

                
                    <title>Adding CORS support to nginx proxy in Kubernetes</title>
                
            </item>
        
            <item>
                
                
                
                
                
                
                

                

                

                

                

                
                

                

                

                
                    <description><![CDATA[<p>At <a href="https://mobingi.com">Mobingi</a>, when we are developing services that run on Kubernetes, we generally use <a href="https://github.com/kubernetes/minikube">Minikube</a> or <a href="https://blog.docker.com/2018/01/docker-mac-kubernetes/">Kubernetes in Docker for Mac</a>. We also have a cluster that runs on <a href="https://cloud.google.com/kubernetes-engine/">GKE</a> that we use for development. In this post, I will share how we access some of the services that are running on our development cluster.</p>
<h2 id="using-kubectl-port-forward">Using kubectl port-forward</h2>
<p>Using <a href="https://kubernetes.io/docs/tasks/access-application-cluster/port-forward-access-application-cluster/">kubectl port-forward</a> is probably the cheapest and the most straightforward. For example, if I want to access a cluster service <code>svc1</code> through my localhost, I use <code>kubectl port-forward</code> like this:</p>
<p>{% highlight shell %}
$ kubectl get pod
NAME                            READY     STATUS    RESTARTS   AGE
svc1-66dd787767-d6b22           2/2       Running   0          7d
svc1-66dd787767-ks92f           2/2       Running   0          7d
svc2-578786c554-rlw2w           2/2       Running   0          7d</p>
<h1 id="this-will-connect-to-the-first-pod-we-have-two-available">This will connect to the first pod (we have two available):</h1>
<p>$ kubectl port-forward <code>kubectl get pod --no-headers=true -o \ custom-columns=:metadata.name | grep svc1 | head -n1</code> 8080:8080
Forwarding from 127.0.0.1:8080 -&gt; 8080
{% endhighlight %}</p>
<p>The left <code>8080</code> is my local port, the right <code>8080</code> is the pod port where svc1 is running.</p>
<p>One thing to note with <code>kubectl port-forward</code> through is that it won&rsquo;t disconnect automatically even when the pod is restarted, say for example, due to an update from CI. I have to restart the command by doing a Ctrl+C and then rerun.</p>
<h2 id="exposing-the-service-using-nodeport-or-loadbalancer">Exposing the service using NodePort or LoadBalancer</h2>
<p>This part is probably the easiest to setup. You can check the details from the Kubernetes <a href="https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types">documentation</a>. But you have to be careful though, especially with load balancers. These are not cheap. We have gone with this route during our early Kubernetes days and we ended up with a lot of load balancers. This was when our clusters were still in AWS. In AWS, (I&rsquo;m not sure if it is still the case now) when you specify <code>LoadBalancer</code> as service type, a classic load balancer will be provisioned for your service. That means one load balancer per exposed service!</p>
<p>When we moved to GKE, we started using <a href="https://github.com/kubernetes/ingress-gce">GLBC</a> which uses an L7 load balancer via the Ingress API. This improved our costs a little bit since GLBC can support up to five backend services per load balancer using paths. The slight downside was that Ingress updates were a bit slow. It&rsquo;s not a big deal though since it&rsquo;s only in the development cluster and we use blue/green deployment in production. But still, some updates can take up to ten minutes.</p>
<h2 id="using-nginx-as-a-reverse-proxy-to-cluster-services">Using nginx as a reverse proxy to cluster services</h2>
<p>In our quest to further minimize costs, we are currently using <a href="https://www.nginx.com/">nginx</a> as our way of exposing services. We provisioned a single Ingress that points to an nginx service which serves as a reverse proxy to our cluster services. This was the cheapest for us as we only have one load balancer for all services. And updating the nginx reverse proxy service takes only a few seconds. So far, this worked for us with no significant problems for the past couple of months.</p>
<p>Here&rsquo;s an example of an nginx reverse proxy service:</p>
<p>{% highlight ruby %}
apiVersion: v1
kind: ConfigMap
metadata:
name: serviceproxy-conf
data:
serviceproxy.conf: |
server {
listen 80;
server_name development.mobingi.com;
resolver kube-dns.kube-system.svc.cluster.local valid=10s;</p>
<pre><code>    location ~ ^/svc1/(.*)$ {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header Host $host;
        rewrite ^/svc1/(.*)$ /$1 break;
        proxy_pass &quot;http://svc1.default.svc.cluster.local&quot;;
        proxy_http_version 1.1;
    }

    location ~ ^/svc2/(.*)$ {
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header Host $host;
        rewrite ^/svc2/(.*)$ /$1 break;
        proxy_pass &quot;http://svc2.default.svc.cluster.local&quot;;
        proxy_http_version 1.1;
    }

    # root health check requirement in GKE ingress
    location / {
        return 200 'healthy\n';
    }
}
</code></pre>
<hr>
<p>apiVersion: apps/v1
kind: Deployment
metadata:
name: serviceproxy
spec:
replicas: 1
revisionHistoryLimit: 3
selector:
matchLabels:
app: serviceproxy
template:
metadata:
labels:
app: serviceproxy
spec:
containers:
- name: nginx
image: nginx:1.13
ports:
- containerPort: 80
volumeMounts:
- name: config-volume
mountPath: /etc/nginx/conf.d/
volumes:
- name: config-volume
configMap:
name: serviceproxy-conf
items:
- key: serviceproxy.conf
path: serviceproxy.conf</p>
<hr>
<p>apiVersion: autoscaling/v1
kind: HorizontalPodAutoscaler
metadata:
name: serviceproxy-hpa
namespace: default
spec:
scaleTargetRef:
apiVersion: apps/v1
kind: Deployment
name: serviceproxy
minReplicas: 1
maxReplicas: 10
targetCPUUtilizationPercentage: 80</p>
<hr>
<p>apiVersion: v1
kind: Service
metadata:
name: serviceproxy
spec:
type: NodePort
ports:</p>
<ul>
<li>name: http
protocol: TCP
port: 80
targetPort: 80
selector:
app: serviceproxy
{% endhighlight %}</li>
</ul>
<p>In this example, all services, mainly <code>svc1</code> and <code>svc2</code>, are running in the <code>default</code> namespace. Save this as service.yaml and deploy:</p>
<p>{% highlight shell %}
$ kubectl create -f service.yaml
{% endhighlight %}</p>
<p>A sample Ingress controller for the reverse proxy service:</p>
<p>{% highlight ruby %}
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
name: serviceproxy-ingress
annotations:
kubernetes.io/ingress.class: &ldquo;gce&rdquo;
spec:
tls:</p>
<ul>
<li>secretName: mobingi-tls
rules:</li>
<li>host: development.mobingi.com
http:
paths:
<ul>
<li>backend:
serviceName: serviceproxy
servicePort: 80
{% endhighlight %}</li>
</ul>
</li>
</ul>
<p>Save this as ingress.yaml and deploy:</p>
<p>{% highlight shell %}
$ kubectl create -f ingress.yaml
{% endhighlight %}</p>
<p>After everything is ready (Ingress provisioning takes some time), you should be able to access <code>svc1</code> through <code>https://development.mobingi.com/svc1/some-endpoint</code>, <code>svc2</code> through <code>https://development.mobingi.com/svc2/another-endpoint</code>, etc. Of course, you have to point your domain to your Ingress load balancer&rsquo;s IP address which you can see using the following command:</p>
<p>{% highlight shell %}
$ kubectl get ingress serviceproxy-ingress
NAME                   HOSTS                     ADDRESS          PORTS     AGE
serviceproxy-ingress   development.mobingi.com   1.2.3.4          80, 443   91d
{% endhighlight %}</p>
<p>If you&rsquo;re wondering how to setup the TLS portion, you can refer to my previous <a href="https://flowerinthenight.com/blog/2018/02/20/k8s-tls-digicert">post</a> about the very subject.</p>
]]></description>
                

                <guid isPermaLink="false">tag:localhost:1313,0001-01-01:/blog/2018-03-31-access-pods-k8s/</guid>

                
                    <link>http://localhost:1313/blog/2018-03-31-access-pods-k8s/</link>
                

                
                    <pubDate>Mon, 01 Jan 0001 00:00:00 UTC</pubDate>
                

                
                    <title>Accessing services in Kubernetes</title>
                
            </item>
        
    </channel>
</rss>
